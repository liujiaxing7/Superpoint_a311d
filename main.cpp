/****************************************************************************
*   Generated by ACUITY 5.11.0
*   Match ovxlib 1.1.21
*
*   Neural Network application project entry file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef __linux__
#include <time.h>
#elif defined(_WIN32)
#include <windows.h>
#include <vector>
#include <cmath>

#endif

#define _BASETSD_H

#include "vsi_nn_pub.h"
#include "vx_khr_cnn.h"

#include "vnn_global.h"
#include "vnn_pre_process.h"
#include "vnn_post_process.h"
#include "vnn_superpointv1.h"

#include <opencv2/opencv.hpp> // opencv

#include <sstream>
#include <dirent.h>
#include <SpRun.h>
#include <Tracker.h>

#define INPUT_META_NUM 1
#define RELEASE(x) {if(nullptr != (x)) free((x)); (x) = nullptr;}
static vnn_input_meta_t input_meta_tab[INPUT_META_NUM];
const std::string SUFFIX_IMAGE = "png bmp tiff tif jpg jpeg PNG JPG JPEG";
/*-------------------------------------------
        Macros and Variables
-------------------------------------------*/

/*-------------------------------------------
                  Functions
-------------------------------------------*/
static void vnn_ReleaseNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    vnn_ReleaseSuperpointV1( graph, TRUE );
    if (vnn_UseImagePreprocessNode())
    {
        vnn_ReleaseBufferImage();
    }
}

static vsi_status vnn_PostProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    return vnn_PostProcessSuperpointV1( graph );
}

#define BILLION                                 1000000000
static uint64_t get_perf_count()
{
#if defined(__linux__) || defined(__ANDROID__) || defined(__QNX__) || defined(__CYGWIN__)
    struct timespec ts;

    clock_gettime(CLOCK_MONOTONIC, &ts);

    return (uint64_t)((uint64_t)ts.tv_nsec + (uint64_t)ts.tv_sec * BILLION);
#elif defined(_WIN32) || defined(UNDER_CE)
    LARGE_INTEGER ln;

    QueryPerformanceCounter(&ln);

    return (uint64_t)ln.QuadPart;
#endif
}

static vsi_status vnn_VerifyGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    /* Verify graph */
    printf("Verify...\n");
    tmsStart = get_perf_count();
    status = vsi_nn_VerifyGraph( graph );
    TEST_CHECK_STATUS(status, final);
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Verify Graph: %ldms or %ldus\n", msVal, usVal);

final:
    return status;
}

static vsi_status vnn_ProcessGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    int32_t i,loop;
    char *loop_s;
    uint64_t tmsStart, tmsEnd, sigStart, sigEnd;
    float msVal, usVal;

    status = VSI_FAILURE;
    loop = 1; /* default loop time is 1 */
    loop_s = getenv("VNN_LOOP_TIME");
    if(loop_s)
    {
        loop = atoi(loop_s);
    }

    /* Run graph */
    tmsStart = get_perf_count();
    printf("Start run graph [%d] times...\n", loop);
    for(i = 0; i < loop; i++)
    {
        sigStart = get_perf_count();
        status = vsi_nn_RunGraph( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Run graph the %d time fail\n", i);
        }
        TEST_CHECK_STATUS( status, final );

        sigEnd = get_perf_count();
        msVal = (sigEnd - sigStart)/1000000;
        usVal = (sigEnd - sigStart)/1000;
        printf("Run the %u time: %.2fms or %.2fus\n", (i + 1), msVal, usVal);
    }
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("vxProcessGraph execution time:\n");
    printf("Total   %.2fms or %.2fus\n", msVal, usVal);
    printf("Average %.2fms or %.2fus\n", ((float)usVal)/1000/loop, ((float)usVal)/loop);

final:
    return status;
}

static vsi_status vnn_PreProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph,
    int argc,
    char **argv
    )
{
    /*
     * argv0:   execute file
     * argv1:   data file
     * argv2~n: inputs n file
     */
    const char **inputs = (const char **)argv + 2;
    uint32_t input_num = argc - 2;

    /*
    if(vnn_UseImagePreprocessNode())
    {
        return vnn_PreProcessSuperpointV1_ImageProcess(graph, inputs, input_num);
    }
    */
    return vnn_PreProcessSuperpointV1( graph, inputs, input_num );
}
static void _load_input_meta()
{
    uint32_t i;
    for (i = 0; i < INPUT_META_NUM; i++)
    {
        memset(&input_meta_tab[i].image.preprocess, VNN_PREPRO_NONE, sizeof(int32_t) * VNN_PREPRO_NUM);
    }
    /* lid: input_256 */
    input_meta_tab[0].image.preprocess[0] = VNN_PREPRO_REORDER;
    input_meta_tab[0].image.preprocess[1] = VNN_PREPRO_MEAN;
    input_meta_tab[0].image.preprocess[2] = VNN_PREPRO_SCALE;
    input_meta_tab[0].image.reorder[0] = 0;
    input_meta_tab[0].image.reorder[1] = 1;
    input_meta_tab[0].image.reorder[2] = 2;
    input_meta_tab[0].image.mean[0] = 123.0;
    input_meta_tab[0].image.mean[1] = 117.0;
    input_meta_tab[0].image.mean[2] = 104.0;
    input_meta_tab[0].image.scale = 0.0078125;


}

static float *_imageData_to_float32(uint8_t *bmpData, vsi_nn_tensor_t *tensor)
{
    float *fdata;
    uint32_t sz,i;

    fdata = nullptr;
    sz = vsi_nn_GetElementNum(tensor);
    fdata = (float *)malloc(sz * sizeof(float));
    TEST_CHECK_PTR(fdata, final);

    for(i = 0; i < sz; i++)
    {
        fdata[i] = (float)bmpData[i];
    }

    final:
    return fdata;
}
static void _data_transform(float *fdata, vnn_input_meta_t *meta, vsi_nn_tensor_t *tensor)
{
    uint32_t s0,s1,s2;
    uint32_t i,j,offset,sz,order;
    float *data;
    uint32_t *reorder;

    data = nullptr;
    reorder = meta->image.reorder;
    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];
    sz = vsi_nn_GetElementNum(tensor);
    data = (float *)malloc(sz * sizeof(float));
    TEST_CHECK_PTR(data, final);
    memset(data, 0, sizeof(float) * sz);

    for(i = 0; i < s2; i++)
    {
        if(s2 > 1 && reorder[i] <= s2)
        {
            order = reorder[i];
        }
        else
        {
            order = i;
        }

        offset = s0 * s1 * i;
        for(j = 0; j < s0 * s1; j++)
        {
            data[j + offset] = fdata[j * s2 + order];
        }
    }


    memcpy(fdata, data, sz * sizeof(float));
    final:
    if(data)free(data);
}

static void _data_mean(float *fdata, vnn_input_meta_t *meta, vsi_nn_tensor_t *tensor)
{
    uint32_t s0,s1,s2;
    uint32_t i,j,offset;
    float val,mean;

    s0 = tensor->attr.size[0];
    s1 = tensor->attr.size[1];
    s2 = tensor->attr.size[2];

    for(i = 0; i < s2; i++)
    {
        offset = s0 * s1 * i;
        mean = meta->image.mean[i];
        for(j = 0; j < s0 * s1; j++)
        {
            val = fdata[offset + j] - mean;
            fdata[offset + j ] = val;
        }
    }

}

static void _data_scale(float *fdata, vnn_input_meta_t *meta, vsi_nn_tensor_t *tensor)
{
    uint32_t i,sz;
    float val,scale;

    sz = vsi_nn_GetElementNum(tensor);
    scale = meta->image.scale;
    if(0 != scale)
    {
        for(i = 0; i < sz; i++)
        {
            val = fdata[i] * scale;
            fdata[i] = val;
        }
    }
}

static uint8_t *_float32_to_dtype(float *fdata, vsi_nn_tensor_t *tensor)
{
    vsi_status status;
    uint8_t *data;
    uint32_t sz,i,stride;

    sz = vsi_nn_GetElementNum(tensor);
    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    data = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    TEST_CHECK_PTR(data, final);
    memset(data, 0, stride * sz * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_Float32ToDtype(fdata[i], &data[stride * i], &tensor->attr.dtype);
        if(status != VSI_SUCCESS)
        {
            if(data)free(data);
            return nullptr;
        }
    }

    final:
    return data;
}

static uint8_t *PreProcess(vsi_nn_tensor_t *tensor, vnn_input_meta_t *meta, uint8_t *bmpData)
{
    uint8_t *data = nullptr;
    float *fdata = nullptr;
    int32_t use_image_process = vnn_UseImagePreprocessNode();

    TEST_CHECK_PTR(bmpData, final);
    if(use_image_process)    return bmpData;

    fdata = _imageData_to_float32(bmpData, tensor);
//    PrintMatrix(fdata, 320);
    TEST_CHECK_PTR(fdata, final);

    for(uint32_t i = 0; i < _cnt_of_array(meta->image.preprocess); i++)
    {
        switch (meta->image.preprocess[i])
        {
            case VNN_PREPRO_NONE:
                break;
            case VNN_PREPRO_REORDER:
                _data_transform(fdata, meta, tensor);
                break;
            case VNN_PREPRO_MEAN:
                _data_mean(fdata, meta, tensor);
                break;
            case VNN_PREPRO_SCALE:
                _data_scale(fdata, meta, tensor);
                break;
            default:
                break;
        }
    }

//    PrintMatrix(fdata, 320);
    data = _float32_to_dtype(fdata, tensor);
//    PrintMatrix(data, 320);
    TEST_CHECK_PTR(data, final);
    final:
    RELEASE(fdata);

    return data;
}

static vsi_status _handle_multiple_inputs(vsi_nn_graph_t *graph, uint8_t* data)
{
    const int inputID = 0;
    vsi_status status = VSI_FAILURE;
    vsi_nn_tensor_t *tensor = nullptr;
    char dumpInput[128];

    tensor = vsi_nn_GetTensor(graph, graph->input.tensors[inputID]);
    data = PreProcess(tensor, &(input_meta_tab[0]), data);
    status = vsi_nn_CopyDataToTensor(graph, tensor, data);
    TEST_CHECK_STATUS(status, final);

    status = VSI_SUCCESS;
    final:
    return status;
}
vsi_status vnnPreProcessFromMat(vsi_nn_graph_t *graph, cv::Mat img)
{
    _load_input_meta();
    vsi_status status = _handle_multiple_inputs(graph, img.data);
    TEST_CHECK_STATUS(status, final);

    status = VSI_SUCCESS;
    final:
    return status;
}

vsi_status vnn_PreProcessNeuralNetworkSuperponit(vsi_nn_graph_t *graph, cv::Mat dst)
{
    dst /= 255.0f;

    _load_input_meta();
    using TYPE = uint8_t;
    TYPE *src = (TYPE *) dst.data;
    vsi_status status = _handle_multiple_inputs(graph, src);
    TEST_CHECK_STATUS(status, final);

    status = VSI_SUCCESS;
    final:
    return status;
}

static vsi_nn_graph_t *vnn_CreateNeuralNetwork
    (
    const char *data_file_name
    )
{
    vsi_nn_graph_t *graph = NULL;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    tmsStart = get_perf_count();
    graph = vnn_CreateSuperpointV1( data_file_name, NULL,
                      vnn_GetPrePorcessMap(), vnn_GetPrePorcessMapCount(),
                      vnn_GetPostPorcessMap(), vnn_GetPostPorcessMapCount() );
    TEST_CHECK_PTR(graph, final);
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Create Neural Network: %ldms or %ldus\n", msVal, usVal);

final:
    return graph;
}

/*-------------------------------------------
                  Main Functions
-------------------------------------------*/
template <class T>
uint64 Multiple(const T* data, const uint size)
{
    uint64 mul = 1;

    for (int i = 0; i < size; i++)
    {
        mul *= data[i];
    }

    return mul;
}

vsi_status GetOutput(vsi_nn_graph_t *graph, vsi_nn_tensor_t *tensor, Array& array)
{
    vsi_status status = VSI_FAILURE;
    array.dims = std::vector<uint>(std::begin(tensor->attr.size), std::begin(tensor->attr.size) + tensor->attr.dim_num);
    uint64 size = Multiple(tensor->attr.size, tensor->attr.dim_num);
    uint stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    uint8_t *tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    array.data = (float *)malloc(sizeof(float) * size);

    for(uint i = 0; i < size; i++)
    {
        status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &array.data[i], &tensor->attr.dtype);
    }

    if(tensor_data) vsi_nn_Free(tensor_data);

    return status;

}
void Array::Release()
{
    RELEASE(data);
}

Array::~Array()
{
    Release();
}
vsi_status PostProcess(vsi_nn_graph_t *graph, cv::Mat img){
    vsi_status status = VSI_FAILURE;

    Array semi, coarse_desc;
    int outpixNum = 80 * 50;


    status = GetOutput(graph, vsi_nn_GetTensor(graph, graph->output.tensors[0]), semi);
    status |= GetOutput(graph, vsi_nn_GetTensor(graph, graph->output.tensors[1]), coarse_desc);

    float*** locresult = new float** [1];
    float*** descresult = new float** [1];

    long long loc_channel = 65;
    long long desc_channel = 256;
    long long width = 640;
    long long height = 400;


    locresult[0] = new float* [loc_channel];
    descresult[0] = new float* [desc_channel];

    for (size_t chanIdx = 0; chanIdx < loc_channel; ++chanIdx)
    {
        // float* single_loc_result_t = new float[outpixNum];
        locresult[0][chanIdx] = &semi.data[loc_channel * chanIdx];
    }

    for (size_t chanIdx = 0; chanIdx < desc_channel; ++chanIdx)
    {
        // float* single_desc_result_t = new float[outpixNum];
        descresult[0][chanIdx] = &coarse_desc.data[desc_channel * chanIdx];
    }

    SpRun* sp = new SpRun(loc_channel, desc_channel, outpixNum, width, height);
    std::cout << " SpRun start " << std::endl;

//    input     - [640, 400, 1, 1]
//    output    - [80, 50, 256, 1]
//    [80, 50, 65, 1]

    //top img
    // locresult_t : (1, loc_channel, outpixNum)  #(1, 256, 50*80)
    float*** locresult_t = new float** [1];
    locresult_t[0] = locresult[0];

    // descresult_t : (1, desc_channel, outpixNum)  #(1, 65, 50*80)
    float*** descresult_t = new float** [1];
    descresult_t[0] = descresult[0];

    sp->calc(locresult_t, descresult_t, img);
    long long top_count = sp->get_count();

    //top_pts : (2, top_count) -> 应用 nms 并保存 x,y 坐标，根据分数降序排列
    long long** top_pts = new long long* [2];
    long long* top_pts_x = new long long[top_count];
    long long* top_pts_y = new long long[top_count];
    top_pts[0] = top_pts_y;
    top_pts[1] = top_pts_x;

    //top_score : (top_count) -> 应用nms，存储降序排列的分数
    double* top_score = new double[top_count];

    //top_pts : (desc_channel, top_count)
    double** top_desc = new double* [desc_channel];
    for (size_t i = 0; i < desc_channel; i++) {
        double* top_desc_ = new double[top_count];
        top_desc[i] = top_desc_;
    }
    sp->get_sp_result(top_pts, top_score, top_desc);

    return VSI_SUCCESS;
}

std::string GetSuffix(const char *fileName)
{
    const char SEPARATOR = '.';
    char buff[32] = {0};

    const char *ptr = strrchr(fileName, SEPARATOR);

    if (nullptr == ptr) return "";

    uint32_t pos = ptr - fileName;
    uint32_t n = strlen(fileName) - (pos + 1);
    strncpy(buff, fileName + (pos + 1), n);

    return buff;
}

bool IsIMAGE(const char *fileName)
{
    std::string suffix = GetSuffix(fileName);

    if (suffix.empty()) return false;
    return SUFFIX_IMAGE.find(suffix) != std::string::npos;
}



void Walk(const std::string& path, const std::string suffixList
        , std::vector<std::string>& fileList)
{
    DIR *dir;
    dir = opendir(path.c_str());
    struct dirent *ent;
    if (nullptr == dir)
    {
        std::cout << "failed to open file " << path << std::endl;
        return;
    }

    while ((ent = readdir(dir)) != nullptr)
    {
        auto name = std::string(ent->d_name);

        // ignore "." ".."
        if (name.size() < 4) continue;

        std::string suffix = GetSuffix(name.c_str());

        if (!suffix.empty() && suffixList.find(suffix) != std::string::npos)
        {
            fileList.emplace_back(path + "/" + name);
        }
        else
        {
            Walk(path + "/" + name, suffixList, fileList);
        }

    }

    closedir(dir);
}

int main
    (
    int argc,
    char **argv
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_graph_t *graph;
    const char *data_name = NULL;

    if(argc < 3)
    {
        printf("Usage: %s data_file inputs...\n", argv[0]);
        return -1;
    }

    data_name = (const char *)argv[1];

    std::vector<std::string> imageFiles({});
    char *path = (argv + 2)[0];

    if (IsIMAGE(path))
    {
        imageFiles.emplace_back(path);
    }
    else
    {
        Walk(path, SUFFIX_IMAGE, imageFiles);
    }
    graph = vnn_CreateNeuralNetwork( data_name );
    TEST_CHECK_PTR( graph, final );

    for (const auto &file : imageFiles)
    {
        int width = 640;
        int height = 400;
        int channel = 1;
        cv::Mat dst;
        cv::Mat orig_img = cv::imread(file, 1);
        cv::resize(orig_img, dst, cv::Size(width, height));

        /* Pre process the image data */
        status = vnn_PreProcessNeuralNetworkSuperponit( graph, dst);
        TEST_CHECK_STATUS( status, final );

        /* Verify graph */
        status = vnn_VerifyGraph( graph );
        TEST_CHECK_STATUS( status, final);
        //
        //    /* Process graph */
        status = vnn_ProcessGraph( graph );
        TEST_CHECK_STATUS( status, final );

        status = PostProcess(graph, dst);
        TEST_CHECK_STATUS( status, final );

    }



//
//    if(VNN_APP_DEBUG)
//    {
//        /* Dump all node outputs */
//        vsi_nn_DumpGraphNodeOutputs(graph, "./network_dump", NULL, 0, TRUE, static_cast<vsi_nn_dim_fmt_e>(0));
//    }
//
//    /* Post process output data */
//    status = vnn_PostProcessNeuralNetwork( graph );
//    TEST_CHECK_STATUS( status, final );

final:
    vnn_ReleaseNeuralNetwork( graph );
    fflush(stdout);
    fflush(stderr);
    return status;
}

